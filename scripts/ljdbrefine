#!/usr/bin/env python

"""
A script to create SPL runs to refine entries in the lj database
"""

__author__ = "Martin Uhrin"
__copyright__ = "Copyright 2014, Martin Uhrin"
__version__ = "0.0.0"
__maintainer__ = "Martin Uhrin"
__email__ = "martin.uhrin.10@ucl.ac.uk"
__date__ = "Aug 12, 2014"

import argparse
import os
import json
import yaml

import matgendb as mgdb
import matgendb.util

import pymatgen.analysis.structure_matcher as structure_matcher

import splpy.lj as lj
import splpy.lj.db_query as db_query
import splpy.lj.util
import splpy.interval as interval
import splpy.resio
from splpy.lj.query_engine import LjQueryEngine


def surrounding_range(params, dist):
    """
    Get the InteractionRange that surround this point in parameter space up to a distance dist
    in each direction
    """
    range = db_query.LennardJonesSearchRange()
    for pair, val in params.interactions.iteritems():
        d = val.__dict__
        intervals = dict()
        for param in ["epsilon", "sigma", "m", "n", "cut"]:
            val = d[param]
            intervals[param] = interval.Closed(val - dist, val + dist)
        range.add_interaction(pair.first, pair.second, db_query.InteractionRange(**intervals))

    return range


def update_spipe_dict(params, structures_dir, d):
    d["loadStructures"] = structures_dir

    params_dict = dict()
    for pair, inter in params.interactions.iteritems():
        params_dict[str(pair)] = [inter.epsilon, inter.sigma, inter.m, inter.n, inter.cut]
    if not d.get("potential"):
        d["potential"] = dict()
    d["potential"]["lennardJones"] = {"params": params_dict}

    return d


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="""
    \n\n
    Author: {}\n
    Version: {}""".format(__author__, __version__))

    parser.add_argument('--quiet', '-q', dest='quiet', action="store_true", default=False,
                        help="Minimal verbosity.")
    parser.add_argument('--verbose', '-v', dest='vb', action="count", default=0,
                        help="Print more verbose messages to standard error. Repeatable. (default=ERROR)")
    parser.add_argument("-c", "--config", dest="config_file", type=str, default="ljdb.json",
                        help="Config file to use. Generate one using mgdb "
                             "init --config filename.json if necessary. "
                             "Otherwise, the code searches for an ljdb.json first"
                             "then ~/.ljdb.json. If none is found, an no-authentication "
                             "localhost:27017/lj database and structures "
                             "collection is assumed.")
    parser.add_argument("--crit", dest="criteria", type=str, default=None,
                        help="Query criteria in typical json format. E.g., "
                             "{\"task_id\": 1}.")
    parser.add_argument("-d", dest="dist", type=float, default=0.1,
                        help="Distance from each parameter point to get structures from.")
    parser.add_argument("spipe_file", metavar="spipe_file", type=str,
                        help="The spipe file to append to.")

    # Parse args
    args = parser.parse_args()

    if not os.path.exists(args.config_file):
        home_config = os.path.expanduser('~/.ljdb.json')
        if os.path.exists(home_config):
            args.config_file = home_config

    d = mgdb.util.get_settings(args.config_file)
    qe = LjQueryEngine(host=d["host"], port=d["port"], database=d["database"],
                       user=d["readonly_user"], password=d["readonly_password"],
                       collection=d["collection"], aliases_config=d.get("aliases_config", None))

    # Get the criteria and extract the parameters range of interest (or all params)
    criteria = json.loads(args.criteria) if args.criteria else dict()
    params_range = lj.db_query.LennardJonesSearchRange()
    if "potential.params" in criteria:
        params_range = lj.db_query.LennardJonesSearchRange.from_dict(criteria.pop("potential.params"))

    matcher = structure_matcher.StructureMatcher()

    for result in qe.params.find(params_range.to_criteria()):
        params = lj.util.LjInteractions.from_dict(result)
        range = surrounding_range(params, args.dist)
        strs = db_query.get_unique_in_range(qe, range, matcher)

        params_id = str(result["_id"])
        try:
            run_dir = params_id
            structures_dir = os.path.join(run_dir, "unique")
            os.makedirs(structures_dir)

            for struct in strs:
                doc = struct.splpy_doc
                res = splpy.resio.Res(struct, doc.get("name"), doc.get("pressure"), doc.get("energy"),
                                      doc.get("spacegroup.symbol"), doc.get("times_found"))
                res.write_file(os.path.join(structures_dir, "{}.res".format(doc["_id"])))


            # Write the spipe yaml file for the run
            with open(os.path.join(run_dir, args.spipe_file), 'w') as outfile:
                spipe_settings = dict()
                if os.path.exists(args.spipe_file):
                    with open(args.spipe_file, 'r') as original:
                        #shutil.copyfileobj(original, outfile)
                        spipe_settings = yaml.load(original)
                update_spipe_dict(params, "unique", spipe_settings)
                outfile.write(yaml.dump(spipe_settings))

            # Write the potparams
            with open('{}.potparams'.format(params_id), 'w') as outfile:
                potparams_line = [run_dir]
                potparams_line.extend([str(v) for v in params.to_array])
                outfile.write(' '.join(potparams_line))
                outfile.write('\n')

        except OSError:
            pass
